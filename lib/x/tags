!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ASSERT	debug.h	4;"	d
CC	Makefile	/^CC=gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS=-g -Wall -ansi -pedantic $/;"	m
CLI_DIR	Makefile	/^CLI_DIR=client$/;"	m
CLI_OBJS	Makefile	/^CLI_OBJS=client.o \\$/;"	m
CLI_TARGET	Makefile	/^CLI_TARGET=cli$/;"	m
DLOG0	dlog.h	16;"	d
DLOG1	dlog.h	19;"	d
DLOG2	dlog.h	22;"	d
DLOG3	dlog.h	25;"	d
DLOG4	dlog.h	28;"	d
LDFLAGS	Makefile	/^LDFLAGS=-pthread$/;"	m
LOG_ALERT	dlog.h	8;"	d
LOG_CRIT	dlog.h	9;"	d
LOG_DEBUG	dlog.h	14;"	d
LOG_EMERG	dlog.h	7;"	d
LOG_ERR	dlog.h	10;"	d
LOG_INFO	dlog.h	13;"	d
LOG_NOTICE	dlog.h	12;"	d
LOG_WARNING	dlog.h	11;"	d
MAX_FILE_LEN	protocols/filetrans.c	49;"	d	file:
NULL_TEST	debug.h	10;"	d
PORT	client.c	20;"	d	file:
PTHREAD_TEST	debug.h	16;"	d
PUT	protocols/filetrans.c	/^	PUT = 0x01$/;"	e	enum:cmds	file:
READ_BUF_SIZE	protocols/filetrans.c	48;"	d	file:
RET_CMD_NOT_FOUND	protocols/filetrans.c	/^	RET_CMD_NOT_FOUND$/;"	e	enum:return_codes	file:
RET_COULDNTOPENFILE	protocols/filetrans.c	/^	RET_COULDNTOPENFILE,$/;"	e	enum:return_codes	file:
RET_ERR	protocols/filetrans.c	/^	RET_ERR,$/;"	e	enum:return_codes	file:
RET_FILEEXIST	protocols/filetrans.c	/^	RET_FILEEXIST,$/;"	e	enum:return_codes	file:
RET_FILENAMEERR	protocols/filetrans.c	/^	RET_FILENAMEERR,$/;"	e	enum:return_codes	file:
RET_NO_CONN_AVAIL	protocols/filetrans.c	/^	RET_NO_CONN_AVAIL,$/;"	e	enum:return_codes	file:
RET_OK	protocols/filetrans.c	/^	RET_OK = 0x00,$/;"	e	enum:return_codes	file:
RET_READ_ERR	protocols/filetrans.c	/^	RET_READ_ERR,$/;"	e	enum:return_codes	file:
RET_TIMEOUT	protocols/filetrans.c	/^	RET_TIMEOUT,$/;"	e	enum:return_codes	file:
RET_WRITE_ERR	protocols/filetrans.c	/^	RET_WRITE_ERR,$/;"	e	enum:return_codes	file:
RW_TIMEOUT_SEC	protocols/filetrans.c	50;"	d	file:
SERV_DIR	Makefile	/^SERV_DIR=server$/;"	m
SERV_OBJS	Makefile	/^SERV_OBJS=server.o \\$/;"	m
SERV_TARGET	Makefile	/^SERV_TARGET=serv$/;"	m
SOCK_TEST	debug.h	25;"	d
VPATH	Makefile	/^VPATH=.:protocols$/;"	m
WORK_THREAD_NUM	server.c	18;"	d	file:
WRITE_BUF_SIZE	protocols/filetrans.c	47;"	d	file:
__DEBUG_H	debug.h	2;"	d
__DLOG_H	dlog.h	2;"	d
__FILETRANS_H	protocols/filetrans.h	2;"	d
__FILE_H	file.h	2;"	d
__PROTOCOL_IF_H	protocols/protocol_if.h	2;"	d
__SOCK_CLI_H	sock_cli.h	2;"	d
__SOCK_SERV_H	sock_serv.h	2;"	d
__THREAD_POOL	thread_pool.h	2;"	d
_client_worker	sock_cli.c	/^static int _client_worker(void *work_)$/;"	f	file:
_cmd_func_map	protocols/filetrans.c	/^} _cmd_func_map[] = {$/;"	v	typeref:struct:cmd_func_map	file:
_cmd_func_map_no	protocols/filetrans.c	/^static int _cmd_func_map_no = sizeof(_cmd_func_map) \/ sizeof(_cmd_func_map[0]);$/;"	v	file:
_return_mesg	protocols/filetrans.c	/^} _return_mesg[] = {	$/;"	v	typeref:struct:return_mesg	file:
_return_mesg_no	protocols/filetrans.c	/^static int _return_mesg_no = sizeof(_return_mesg) \/ sizeof(_return_mesg[0]);$/;"	v	file:
_server_conn_res	sock_serv.c	/^static void _server_conn_res(void *work_, bool succ)$/;"	f	file:
_server_thread	sock_serv.c	/^static void *_server_thread(void *sh_arg)$/;"	f	file:
_server_worker	sock_serv.c	/^static void *_server_worker(void *work_)$/;"	f	file:
busy	thread_pool.c	/^	bool busy;$/;"	m	struct:thread	file:
cli_func	protocols/filetrans.c	/^	int (*cli_func)(int fd, void *data);$/;"	m	struct:cmd_func_map	file:
cli_proto_ft_free	protocols/filetrans.c	/^static void cli_proto_ft_free(struct cproto_if *self)$/;"	f	file:
cli_proto_ft_init	protocols/filetrans.c	/^struct cproto_if *cli_proto_ft_init(void)$/;"	f
cli_put	protocols/filetrans.c	/^static int cli_put(int fd, void *arg)$/;"	f	file:
client_create	sock_cli.c	/^struct client_handle *client_create(struct cproto_if *ph, char *host, int port)$/;"	f
client_do	sock_cli.c	/^int client_do(struct client_handle *ch, const char *cmd, void *data)$/;"	f
client_handle	sock_cli.c	/^struct client_handle {$/;"	s	file:
client_stop	sock_cli.c	/^int client_stop(struct client_handle *ch)$/;"	f
cmd	protocols/filetrans.c	/^	uint16_t cmd;$/;"	m	struct:cmd_func_map	file:
cmd	sock_cli.c	/^	const char *cmd;$/;"	m	struct:work	file:
cmd_func_map	protocols/filetrans.c	/^static struct cmd_func_map {$/;"	s	file:
cmd_str	protocols/filetrans.c	/^	char *cmd_str;$/;"	m	struct:cmd_func_map	file:
cmds	protocols/filetrans.c	/^enum cmds {$/;"	g	file:
code	protocols/filetrans.c	/^	int code;$/;"	m	struct:return_mesg	file:
cond	thread_pool.c	/^	pthread_cond_t cond;	$/;"	m	struct:thread	file:
conn_res	protocols/protocol_if.h	/^	void (*conn_res)(struct sproto_if *self, int fd, bool succ);$/;"	m	struct:sproto_if
cproto_if	protocols/protocol_if.h	/^struct cproto_if {$/;"	s
data	sock_cli.c	/^	void *data;$/;"	m	struct:work	file:
data	thread_pool.c	/^	void *data;$/;"	m	struct:thread	file:
dlog	debug.c	/^int dlog(int level, char *message, ...)$/;"	f
dlog	dlog.c	/^void dlog(int level, const char *filename, int line,$/;"	f
do_cli_cmd	protocols/filetrans.c	/^static int do_cli_cmd(struct cproto_if *self, int fd, const char *cmd, void *data)$/;"	f	file:
do_cmd	protocols/protocol_if.h	/^	int (*do_cmd)(struct cproto_if *self, $/;"	m	struct:cproto_if
do_cmd	protocols/protocol_if.h	/^	int (*do_cmd)(struct sproto_if *self, int fd);$/;"	m	struct:sproto_if
do_serv_cmd	protocols/filetrans.c	/^static int do_serv_cmd(struct sproto_if *self, int fd)$/;"	f	file:
fd	sock_cli.c	/^	int fd;		$/;"	m	struct:work	file:
fd	sock_cli.c	/^	int fd;$/;"	m	struct:client_handle	file:
fd	sock_serv.c	/^	int fd;		$/;"	m	struct:work	file:
fd	sock_serv.c	/^	int fd;$/;"	m	struct:server_handle	file:
file_len	file.c	/^int file_len(char *filename)$/;"	f
free	protocols/protocol_if.h	/^	void (*free)(struct cproto_if *self);$/;"	m	struct:cproto_if
free	protocols/protocol_if.h	/^	void (*free)(struct sproto_if *self);$/;"	m	struct:sproto_if
func	thread_pool.c	/^	void *(*func)(void *arg);$/;"	m	struct:thread	file:
get_cli_proto_error	protocols/filetrans.c	/^static const char *get_cli_proto_error(struct cproto_if *self, int error_no)$/;"	f	file:
get_proto_error	protocols/filetrans.c	/^static const char *get_proto_error(int error_no)$/;"	f	file:
get_proto_error	protocols/protocol_if.h	/^	const char *(*get_proto_error)(struct cproto_if *self, int error_no);$/;"	m	struct:cproto_if
get_proto_error	protocols/protocol_if.h	/^	const char *(*get_proto_error)(struct sproto_if *self, int error_no);$/;"	m	struct:sproto_if
get_serv_proto_error	protocols/filetrans.c	/^static const char *get_serv_proto_error(struct sproto_if *self, int error_no)$/;"	f	file:
main	client.c	/^int main(int argc, char **argv)$/;"	f
main	server.c	/^int main(int argc, char **argv)$/;"	f
main	tests/thread_pool_test.c	/^int main(int argc, char **argv)$/;"	f
max	sock_serv.c	/^	int max; \/* max connections *\/$/;"	m	struct:server_handle	file:
mesg	protocols/filetrans.c	/^	char *mesg;$/;"	m	struct:return_mesg	file:
mutex	thread_pool.c	/^	pthread_mutex_t mutex;	$/;"	m	struct:thread	file:
mutex	thread_pool.c	/^	pthread_mutex_t mutex;$/;"	m	struct:thread_pool	file:
num	thread_pool.c	/^	int num;$/;"	m	struct:thread	file:
num	thread_pool.c	/^	int num;$/;"	m	struct:thread_pool	file:
ph	sock_cli.c	/^	struct cproto_if *ph;$/;"	m	struct:client_handle	typeref:struct:client_handle::cproto_if	file:
ph	sock_cli.c	/^	struct cproto_if *ph;$/;"	m	struct:work	typeref:struct:work::cproto_if	file:
ph	sock_serv.c	/^	struct sproto_if *ph;$/;"	m	struct:server_handle	typeref:struct:server_handle::sproto_if	file:
ph	sock_serv.c	/^	struct sproto_if *ph;$/;"	m	struct:work	typeref:struct:work::sproto_if	file:
port	sock_serv.c	/^	int port;$/;"	m	struct:server_handle	file:
read_to	protocols/filetrans.c	/^static int read_to(int fd, struct timeval *timeout, $/;"	f	file:
return_codes	protocols/filetrans.c	/^enum return_codes {$/;"	g	file:
return_mesg	protocols/filetrans.c	/^static struct return_mesg {$/;"	s	file:
serv_conn_res	protocols/filetrans.c	/^static void serv_conn_res(struct sproto_if *self, int fd, bool succ){$/;"	f	file:
serv_func	protocols/filetrans.c	/^	int (*serv_func)(int fd);$/;"	m	struct:cmd_func_map	file:
serv_proto_ft_free	protocols/filetrans.c	/^static void serv_proto_ft_free(struct sproto_if *self)$/;"	f	file:
serv_proto_ft_init	protocols/filetrans.c	/^struct sproto_if *serv_proto_ft_init(void)$/;"	f
serv_put	protocols/filetrans.c	/^static int serv_put(int fd)$/;"	f	file:
server_create	sock_serv.c	/^struct server_handle *server_create(struct sproto_if *ph, int port, int max)$/;"	f
server_handle	sock_serv.c	/^struct server_handle {$/;"	s	file:
server_stop	sock_serv.c	/^int server_stop(struct server_handle *sh)$/;"	f
signal_pipe	client.c	/^static void signal_pipe(int signo)$/;"	f	file:
signal_pipe	server.c	/^static void signal_pipe(int signo)$/;"	f	file:
sproto_if	protocols/protocol_if.h	/^struct sproto_if {$/;"	s
thread	thread_pool.c	/^struct thread {$/;"	s	file:
thread_pool	thread_pool.c	/^struct thread_pool {$/;"	s	file:
thread_pool_add_work	thread_pool.c	/^int thread_pool_add_work(struct thread_pool *poolh, void *data,$/;"	f
thread_pool_free	thread_pool.c	/^int thread_pool_free(struct thread_pool *poolh)$/;"	f
thread_pool_init	thread_pool.c	/^struct thread_pool *thread_pool_init(int num, void *(*func)(void *arg))$/;"	f
threads	thread_pool.c	/^	struct thread **threads;$/;"	m	struct:thread_pool	typeref:struct:thread_pool::thread	file:
tid	thread_pool.c	/^	pthread_t tid; \/* thread id *\/$/;"	m	struct:thread	file:
tpoolh	sock_serv.c	/^	struct thread_pool *tpoolh;$/;"	m	struct:server_handle	typeref:struct:server_handle::thread_pool	file:
usage	client.c	/^static void usage(char *name)$/;"	f	file:
usage	server.c	/^static void usage(char *name)$/;"	f	file:
work	sock_cli.c	/^struct work{$/;"	s	file:
work	sock_serv.c	/^struct work{$/;"	s	file:
worker	thread_pool.c	/^static void *worker(void *data)$/;"	f	file:
worker_thread	tests/thread_pool_test.c	/^void *worker_thread(void *arg)$/;"	f
write_to	protocols/filetrans.c	/^static int write_to(int fd, struct timeval *timeout, $/;"	f	file:
